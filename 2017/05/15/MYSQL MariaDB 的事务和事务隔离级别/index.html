<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>MYSQL MariaDB 的事务和事务隔离级别 | Hexo</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MYSQL MariaDB 的事务和事务隔离级别</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">MYSQL MariaDB 的事务和事务隔离级别</h1><div class="post-meta"><a href="/2017/05/15/MYSQL MariaDB 的事务和事务隔离级别/#comments" class="comment-count"></a><p><span class="date">May 15, 2017</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Schlägt</i></i></span></p></div><div class="post-content"><h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h3><h6 id="事务具有ACID特性：原子性-A-atomicity-、一致性-C-consistency-、隔离性-I-isolation-、持久性-D-durabulity-。"><a href="#事务具有ACID特性：原子性-A-atomicity-、一致性-C-consistency-、隔离性-I-isolation-、持久性-D-durabulity-。" class="headerlink" title="事务具有ACID特性：原子性(A,atomicity)、一致性(C,consistency)、隔离性(I,isolation)、持久性(D,durabulity)。"></a>事务具有ACID特性：原子性(A,atomicity)、一致性(C,consistency)、隔离性(I,isolation)、持久性(D,durabulity)。</h6><h6 id="原子性：事务内的所有操作要么都执行，要么都不执行。"><a href="#原子性：事务内的所有操作要么都执行，要么都不执行。" class="headerlink" title="原子性：事务内的所有操作要么都执行，要么都不执行。"></a>原子性：事务内的所有操作要么都执行，要么都不执行。</h6><h6 id="一致性：事务开始和结束前后，数据都满足数据一致性约束，而不是经过事务控制之后数据变得不满足条件或业务规则。"><a href="#一致性：事务开始和结束前后，数据都满足数据一致性约束，而不是经过事务控制之后数据变得不满足条件或业务规则。" class="headerlink" title="一致性：事务开始和结束前后，数据都满足数据一致性约束，而不是经过事务控制之后数据变得不满足条件或业务规则。"></a>一致性：事务开始和结束前后，数据都满足数据一致性约束，而不是经过事务控制之后数据变得不满足条件或业务规则。</h6><h6 id="隔离性：事务之间不能互影响，它们必须完全的各行其道，互不可见。"><a href="#隔离性：事务之间不能互影响，它们必须完全的各行其道，互不可见。" class="headerlink" title="隔离性：事务之间不能互影响，它们必须完全的各行其道，互不可见。"></a>隔离性：事务之间不能互影响，它们必须完全的各行其道，互不可见。</h6><a id="more"></a>
<h6 id="持久性：事务完成后，该事务内涉及的数据必须持久性的写入磁盘保证其持久性。当然，这是从事务的角度来考虑的的持久性，从操作系统故障或硬件故障来说，这是不一定的。"><a href="#持久性：事务完成后，该事务内涉及的数据必须持久性的写入磁盘保证其持久性。当然，这是从事务的角度来考虑的的持久性，从操作系统故障或硬件故障来说，这是不一定的。" class="headerlink" title="持久性：事务完成后，该事务内涉及的数据必须持久性的写入磁盘保证其持久性。当然，这是从事务的角度来考虑的的持久性，从操作系统故障或硬件故障来说，这是不一定的。"></a>持久性：事务完成后，该事务内涉及的数据必须持久性的写入磁盘保证其持久性。当然，这是从事务的角度来考虑的的持久性，从操作系统故障或硬件故障来说，这是不一定的。</h6><h3 id="事务分类"><a href="#事务分类" class="headerlink" title="事务分类"></a>事务分类</h3><blockquote>
<p>扁平事务<br>带保存点的扁平事务<br>链事务<br>嵌套事务<br>分布式事务  </p>
</blockquote>
<h5 id="扁平事务"><a href="#扁平事务" class="headerlink" title="扁平事务"></a>扁平事务</h5><blockquote>
<p>即最常见的事务。由begin开始，commit或rollback结束，中间的所有操作要么都回滚要么都提交。扁平事务在生产环境中占绝大多数使用情况。因此每一种数据库产品都支持扁平事务。  </p>
</blockquote>
<blockquote>
<p>扁平事务的缺点在于无法回滚或提交一部分，只能全部回滚或全部提交，所以就有了”带有保存点”的扁平事务。  </p>
</blockquote>
<h5 id="带有保存点的扁平事务"><a href="#带有保存点的扁平事务" class="headerlink" title="带有保存点的扁平事务"></a>带有保存点的扁平事务</h5><h6 id="通过在事务内部的某个位置使用savepoint，将来可以在事务中回滚到此位置。"><a href="#通过在事务内部的某个位置使用savepoint，将来可以在事务中回滚到此位置。" class="headerlink" title="通过在事务内部的某个位置使用savepoint，将来可以在事务中回滚到此位置。"></a>通过在事务内部的某个位置使用savepoint，将来可以在事务中回滚到此位置。</h6><blockquote>
<p>MariaDB/MySQL中设置保存点的命令为:  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">savepoint [savepoint_name]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>回滚到指定保存点的命令为：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollback to savepoint_name</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除一个保存点的命令为：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">release savepoint savepoint_name</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上，扁平事务也是有保存点的，只不过它只有一个隐式的保存点，且自动建立在事务开始的位置，因此扁平事务只能回滚到事务开始处。  </p>
</blockquote>
<h5 id="链式事务"><a href="#链式事务" class="headerlink" title="链式事务"></a>链式事务</h5><blockquote>
<p>链式事务是保存点扁平事务的变种。它在一个事务提交的时候自动隐式的将上下文传给下一个事务，也就是说一个事务的提交和下一个事务的开始是原子性的，下一个事务可以看到上一个事务的处理结果。通俗地说，就是事务的提交和事务的开始是链接式下去的。  </p>
</blockquote>
<blockquote>
<p>这样的事务类型，在提交事务的时候，会释放要提交事务内所有的锁和要提交事务内所有的保存点。因此链式事务只能回滚到当前所在事务的保存点，而不能回滚到已提交的事务中的保存点。  </p>
</blockquote>
<h5 id="嵌套事务"><a href="#嵌套事务" class="headerlink" title="嵌套事务"></a>嵌套事务</h5><blockquote>
<p>嵌套事务由一个顶层事务控制所有的子事务。子事务的提交完成后不会真的提交，而是等到顶层事务提交才真正的提交。  </p>
</blockquote>
<h6 id="关于嵌套事务的机制，主要有以下3个结论："><a href="#关于嵌套事务的机制，主要有以下3个结论：" class="headerlink" title="关于嵌套事务的机制，主要有以下3个结论："></a>关于嵌套事务的机制，主要有以下3个结论：</h6><blockquote>
<p>回滚内部事务的同时会回滚到外部事务的起始点。  </p>
<p>事务提交时从内向外依次提交。  </p>
<p>回滚外部事务的同时会回滚所有事务，包括已提交的内部事务。因为只提交内部事务时没有真的提交。 </p>
</blockquote>
<h6 id="不管怎么样，最好少用嵌套事务。且MariaDB-MySQL不原生态支持嵌套事务-SQL-Server支持-。"><a href="#不管怎么样，最好少用嵌套事务。且MariaDB-MySQL不原生态支持嵌套事务-SQL-Server支持-。" class="headerlink" title="不管怎么样，最好少用嵌套事务。且MariaDB/MySQL不原生态支持嵌套事务(SQL Server支持)。"></a>不管怎么样，最好少用嵌套事务。且MariaDB/MySQL不原生态支持嵌套事务(SQL Server支持)。</h6><h5 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h5><h6 id="将多个服务器上的事务-节点-组合形成一个遵循事务特性-acid-的分布式事务。"><a href="#将多个服务器上的事务-节点-组合形成一个遵循事务特性-acid-的分布式事务。" class="headerlink" title="将多个服务器上的事务(节点)组合形成一个遵循事务特性(acid)的分布式事务。"></a>将多个服务器上的事务(节点)组合形成一个遵循事务特性(acid)的分布式事务。</h6><blockquote>
<p>例如在工行atm机转账到建行用户。工行atm机所在数据库是一个事务节点A，建行数据库是一个事务节点B，仅靠工行atm机是无法完成转账工作的，因为它控制不了建行的事务。所以它们组成一个分布式事务：  </p>
</blockquote>
<blockquote>
<p>1.atm机发出转账口令。<br>2.atm机从工行用户减少N元。<br>3.在建行用户增加N元。<br>4.在atm机上返回转账成功或失败。  </p>
</blockquote>
<blockquote>
<p>上面涉及了两个事务节点，这些事务节点之间的事务必须同时具有acid属性，要么所有的事务都成功，要么所有的事务都失败，不能只成功atm机的事务，而建行的事务失败。  </p>
</blockquote>
<blockquote>
<p>MariaDB/MySQL的分布式事务使用两段式提交协议(2-phase commit,2PC)。最重要的是，MySQL 5.7.7之前，MySQL对分布式事务的支持一直都不完善(第一阶段提交后不会写binlog，导致宕机丢失日志)，这个问题持续时间长达数十年，直到MySQL 5.7.7，才完美支持分布式事务。相关内容可参考网上一篇文章：<a href="https://www.linuxidc.com/Linux/2016-02/128053.htm。遗憾的是，MariaDB至今" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2016-02/128053.htm。遗憾的是，MariaDB至今</a>(MariaDB 10.3.6)都没有解决这个问题。  </p>
</blockquote>
<h5 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h5><blockquote>
<p>begin 和 start transaction表示显式开启一个事务。它们之间并没有什么区别，但是在存储过程中，begin会被识别成begin…end的语句块，所以存储过程只能使用start transaction来显式开启一个事务。  </p>
</blockquote>
<blockquote>
<p>commit 和 commit work用于提交一个事务。  </p>
</blockquote>
<blockquote>
<p>rollbac 和 rollback work用于回滚一个事务。  </p>
</blockquote>
<blockquote>
<p>savepoint identifier表示在事务中创建一个保存点。一个事务中允许存在多个保存点。  </p>
</blockquote>
<blockquote>
<p>release savepoint identifier表示删除一个保存点。当要删除的保存点不存在的时候会抛出异常。  </p>
</blockquote>
<blockquote>
<p>rollback to savepoint表示回滚到指定的保存点，回滚到保存点后，该保存点之后的所有操纵都被回滚。注意，rollback to不会结束事务，只是回到某一个保存点的状态。  </p>
</blockquote>
<blockquote>
<p>set transaction用来设置事务的隔离级别。可设置的隔离级别有read uncommitted/read committed/repeatable read/serializable。  </p>
</blockquote>
<blockquote>
<p>commit与commit work以及rollback与rollback work作用是一样的。但是他们的作用却和变量  </p>
</blockquote>
<blockquote>
<p>completion_type的值有关。</p>
</blockquote>
<p><img src="https://images2018.cnblogs.com/blog/733013/201805/733013-20180506104848672-2109792794.png" alt="image"></p>
<p>######<br>例如将completion_type设置为1，进行测试。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set completion_type=1;</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; insert into ttt values(1000);</span><br><span class="line">mysql&gt; commit work;</span><br><span class="line">mysql&gt; insert into ttt values(2000);</span><br><span class="line">mysql&gt; rollback;</span><br><span class="line">mysql&gt; select * from ttt where id&gt;=1000;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 1000 |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>begin开始事务后，插入了值为1000的记录，commit work了一次，然后再插入了值为2000的记录后rollback，查询结果结果中只显示了1000，而没有2000，因为commit work提交后自动又开启了一个事务，使用rollback会回滚该事务。  </p>
</blockquote>
<h6 id="将completion-type设置为2，进行测试。"><a href="#将completion-type设置为2，进行测试。" class="headerlink" title="将completion_type设置为2，进行测试。"></a>将completion_type设置为2，进行测试。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set completion_type=2;</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; insert into ttt select 1000;</span><br><span class="line">mysql&gt; commit;</span><br></pre></td></tr></table></figure>
<h6 id="提交后，再查询或者进行其他操作，结果提示已经和MariaDB-MySQL服务器断开连接了。"><a href="#提交后，再查询或者进行其他操作，结果提示已经和MariaDB-MySQL服务器断开连接了。" class="headerlink" title="提交后，再查询或者进行其他操作，结果提示已经和MariaDB/MySQL服务器断开连接了。"></a>提交后，再查询或者进行其他操作，结果提示已经和MariaDB/MySQL服务器断开连接了。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from ttt;</span><br><span class="line">ERROR 2006 (HY000): MySQL server has gone away</span><br><span class="line">No connection. Trying to reconnect...</span><br></pre></td></tr></table></figure>
<h3 id="显式事务的次数统计"><a href="#显式事务的次数统计" class="headerlink" title="显式事务的次数统计"></a>显式事务的次数统计</h3><h6 id="通过全局状态变量com-commit和com-rollback可以查看当前已经显式提交和显式回滚事务的次数。还可以看到回滚到保存点的次数。"><a href="#通过全局状态变量com-commit和com-rollback可以查看当前已经显式提交和显式回滚事务的次数。还可以看到回滚到保存点的次数。" class="headerlink" title="通过全局状态变量com_commit和com_rollback可以查看当前已经显式提交和显式回滚事务的次数。还可以看到回滚到保存点的次数。"></a>通过全局状态变量com_commit和com_rollback可以查看当前已经显式提交和显式回滚事务的次数。还可以看到回滚到保存点的次数。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &quot;%com_commit%&quot;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Com_commit    | 14    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">mysql&gt; show global status like &quot;%com_rollback%&quot;;</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| Variable_name             | Value |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| Com_rollback              | 24    |</span><br><span class="line">| Com_rollback_to_savepoint | 0     |</span><br><span class="line">+---------------------------+-------+</span><br></pre></td></tr></table></figure>
<h3 id="一致性非锁定读-快照查询"><a href="#一致性非锁定读-快照查询" class="headerlink" title="一致性非锁定读(快照查询)"></a>一致性非锁定读(快照查询)</h3><blockquote>
<p>在innodb存储引擎中，存在一种数据查询方式：快照查询。因为查询的是快照数据，所以查询时不申请共享锁。  </p>
</blockquote>
<blockquote>
<p>当进行一致性非锁定读查询的时候，查询操作不会去等待记录上的独占锁释放，而是直接去读取快照数据。快照数据是通过undo段来实现的，因此它基本不会产生开销。显然，通过这种方式，可以极大的提高读并发性。<br><img src="https://images2018.cnblogs.com/blog/733013/201805/733013-20180506105838093-1299081173.png" alt="image"></p>
</blockquote>
<blockquote>
<p>快照数据其实是行版本数据，一个行记录可能会存在多个行版本，并发时这种读取行版本的方式称为多版本并发控制(MVCC)。在隔离级别为read committed和repeatable read时，采取的查询方式就是一致性非锁定读方式。但是，不同的隔离级别下，读取行版本的方式是不一样的。在后面介绍对应的隔离级别时会作出说明。  </p>
<p>下面是在innodb默认的隔离级别是repeatable read下的实验，该隔离级别下，事务总是在开启的时候获取最新的行版本，并一直持有该版本直到事务结束。更多的”一致性非锁定读”见后文说明read committed和repeatable read部分。  </p>
</blockquote>
<h6 id="当前示例表ttt的记录如下："><a href="#当前示例表ttt的记录如下：" class="headerlink" title="当前示例表ttt的记录如下："></a>当前示例表ttt的记录如下：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from ttt;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<h6 id="在会话1执行："><a href="#在会话1执行：" class="headerlink" title="在会话1执行："></a>在会话1执行：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; update ttt set id=100 where id=1</span><br></pre></td></tr></table></figure>
<h6 id="在会话2中执行："><a href="#在会话2中执行：" class="headerlink" title="在会话2中执行："></a>在会话2中执行：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; select * from ttt;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<h6 id="查询的结果和预期的一样，来自开启事务前最新提交的行版本数据。"><a href="#查询的结果和预期的一样，来自开启事务前最新提交的行版本数据。" class="headerlink" title="查询的结果和预期的一样，来自开启事务前最新提交的行版本数据。"></a>查询的结果和预期的一样，来自开启事务前最新提交的行版本数据。</h6><blockquote>
<p>回到会话1提交事务：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; commit;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再回到会话2中查询：   </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from ttt;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再次去会话1更新该记录：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; update ttt set id=1000 where id=100;</span><br><span class="line">mysql&gt; commit;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再回到会话2执行查询：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from ttt;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这就是repeatable read隔离级别下的一致性非锁定读的特性。  </p>
<p>当然，MySQL也支持一致性锁定读的方式。  </p>
</blockquote>
<h3 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h3><blockquote>
<p>在隔离级别为read committed和repeatable read时，采取的查询方式就是一致性非锁定读方式。但是在某些情况下，需要人为的对读操作进行加锁。MySQL中对这种方式的支持是通过在select语句后加上lock in share mode或者for update。  </p>
</blockquote>
<blockquote>
<p>select … from … where … lock in share mode;  </p>
</blockquote>
<blockquote>
<p>select …from … where … for update;  </p>
</blockquote>
<blockquote>
<p>使用lock in share mode会对select语句要查询的记录加上一个共享锁(S)，使用for update语句会对select语句要查询的记录加上独占锁(X)。  </p>
</blockquote>
<blockquote>
<p>另外，对于一致性非锁定读操作，即使要查询的记录已经被for update加上了独占锁，也一样可以读取，就和纯粹的update加的锁一样，只不过此时读取的是快照数据而已。  </p>
</blockquote>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><blockquote>
<p>SQL标准定义了4中隔离级别：read uncommitted、read committed、repeatable read、serializable。  </p>
</blockquote>
<blockquote>
<p>MariaDB/MySQL也支持这4种隔离级别。但是要注意的是，MySQL中实现的隔离级别和SQL Server实现的隔离级别在同级别上有些差别。在后面有必要说明地方会给出它们的差异之处。  </p>
<p> MariaDB/MySQL中默认的隔离级别是repeatable read，SQL Server和oracle的默认隔离级别都是read committed。  </p>
</blockquote>
<blockquote>
<p>事务特性(ACID)中的隔离性(I,isolation)就是隔离级别，它通过锁来实现。也就是说，设置不同的隔离级别，其本质只是控制不同的锁行为。例如操作是否申请锁，什么时候申请锁，申请的锁是立刻释放还是持久持有直到事务结束才释放等。  </p>
</blockquote>
<h5 id="设置和查看事务隔离级别"><a href="#设置和查看事务隔离级别" class="headerlink" title="设置和查看事务隔离级别"></a>设置和查看事务隔离级别</h5><blockquote>
<p>隔离级别是基于会话设置的，当然也可以基于全局进行设置，设置为全局时，不会影响当前会话的级别。设置的方法是：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set [global | session] transaction isolation level &#123;type&#125;</span><br><span class="line">type:</span><br><span class="line">    read uncommitted | read committed | repeatable read | serializable</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者直接修改变量值也可以：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set @@global.tx_isolation = &apos;read-uncommitted&apos; | &apos;read-committed&apos; | &apos;repeatable-read&apos; | &apos;serializable&apos;</span><br><span class="line">set @@session.tx_isolation = &apos;read-uncommitted&apos; | &apos;read-committed&apos; | &apos;repeatable-read&apos; | &apos;serializable&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看当前会话的隔离级别方法如下：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@tx_isolation;</span><br><span class="line">mysql&gt; select @@global.tx_isolation;</span><br><span class="line">mysql&gt; select @@tx_isolation;select @@global.tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">+-----------------------+</span><br><span class="line">| @@global.tx_isolation |</span><br><span class="line">+-----------------------+</span><br><span class="line">| REPEATABLE-READ       |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，事务隔离级别的设置只需在需要的一端设置，不用在两边会话都设置。例如想要让会话2的查询加锁，则只需在会话2上设置serializable，在会话1设置的serializable对会话2是没有影响的，这和SQL Server中一样。但是，MariaDB/MySQL除了serializable隔离级别，其他的隔离级别都默认会读取旧的行版本，所以查询永远不会造成阻塞。而SQL Server中只有基于快照的两种隔离级别才会读取行版本，所以在4种标准的隔离级别下，如果查询加的S锁被阻塞，查询会进入锁等待。  </p>
</blockquote>
<blockquote>
<p>在MariaDB/MySQL中不会出现更新丢失的问题，因为独占锁一直持有直到事务结束。当1个会话开启事务A修改某记录，另一个会话也开启事务B修改该记录，该修改被阻塞，当事务A提交后，事务B中的更新立刻执行成功，但是执行成功后查询却发现数据并没有随着事务B的想法而改变，因为这时候事务B更新的那条记录已经不是原来的记录了。但是事务A回滚的话，事务B是可以正常更新的，但这没有丢失更新。  </p>
</blockquote>
<h5 id="read-uncommitted"><a href="#read-uncommitted" class="headerlink" title="read uncommitted"></a>read uncommitted</h5><blockquote>
<p>该级别称为未提交读，即允许读取未提交的数据。  </p>
</blockquote>
<blockquote>
<p>在该隔离级别下，读数据的时候不会申请读锁，所以也不会出现查询被阻塞的情况。  </p>
</blockquote>
<blockquote>
<p>在会话1执行：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table ttt(id int);</span><br><span class="line">insert into ttt select 1;</span><br><span class="line">insert into ttt select 2;</span><br><span class="line">begin;</span><br><span class="line">update ttt set id=10 where id=1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果会话1的隔离级别不是默认的，那么在执行update的过程中，可能会遇到以下错误：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1665 (HY000): Cannot execute statement: impossible to write to binary log since BINLOG_FORMAT = STATEMENT and at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED or READ UNCOMMITTED.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是read committed和read uncommitted两个隔离级别只允许row格式的二进制日志记录格式。而当前的二进制日志格式记录方式为statement时就会报错。要解决这个问题，只要将格式设置为row或者mixed即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set @@session.binlog_format=row;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在会话2执行：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set transaction isolation level read uncommitted;</span><br><span class="line">select * from ttt;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|   10 |</span><br><span class="line">|    2 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>发现查询的结果是update后的数据，但是这个数据是会话1未提交的数据。这是脏读的问题，即读取了未提交的脏数据。  </p>
</blockquote>
<blockquote>
<p>如果此时会话1进行了回滚操作，那么会话2上查询的结果又变成了id=1。  </p>
</blockquote>
<blockquote>
<p>在会话1上执行：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在会话2上查询：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from ttt;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是读不一致问题。即同一个会话中对同一条记录的读取结果不一致。  </p>
</blockquote>
<blockquote>
<p>read uncommitted一般不会在生产环境中使用，因为问题太多，会导致脏读、丢失的更新、幻影读、读不一致的问题。但由于不申请读锁，从理论上来说，它的并发性是最佳的。所以在某些特殊情况下还是会考虑使用该级别。  </p>
</blockquote>
<blockquote>
<p>要解决脏读、读不一致问题，只需在查询记录的时候加上共享锁即可。这样在其他事务更新数据的时候就无法查询到更新前的记录。这就是read commmitted隔离级别。  </p>
</blockquote>
<h5 id="read-committed"><a href="#read-committed" class="headerlink" title="read committed"></a>read committed</h5><blockquote>
<p>对于熟悉SQL Server的人来说，在说明这个隔离级别之前，必须先给个提醒：MariaDB/MySQL中的提交读和SQL Server中的提交读完全不一样，MariaDB/MySQL中该级别基本类似于SQL Server中基于快照的提交读。  </p>
</blockquote>
<blockquote>
<p>在SQL Server中，提交读的查询会申请共享锁，并且在查询结束的一刻立即释放共享锁，如果要查询的记录正好被独占锁锁住，则会进入锁等待，而没有被独占锁锁住的记录则可以正常查询。SQL Server中基于快照的提交读实现的是语句级的事务一致性，每执行一次操作事务序列号加1，并且每次查询的结果都是最新提交的行版本快照。   </p>
</blockquote>
<blockquote>
<p>也就是说，MariaDB/MySQL中read committed级别总是会读取最新提交的行版本。这在MySQL的innodb中算是一个术语:”一致性非锁定读”，即只读取快照数据，不加共享锁。这在前文已经说明过。  </p>
</blockquote>
<blockquote>
<p>MariaDB/MySQL中的read committed隔离级别下，除非是要检查外键约束或者唯一性约束需要用到gap lock算法，其他时候都不会用到。也就是说在此隔离级别下，一般来说只会对行进行锁定，不会锁定范围，所以会导致幻影读问题。  </p>
</blockquote>
<blockquote>
<p>这里要演示的就是在该级别下，会不断的读取最新提交的行版本数据。  </p>
</blockquote>
<h6 id="当前示例表ttt的记录如下：-1"><a href="#当前示例表ttt的记录如下：-1" class="headerlink" title="当前示例表ttt的记录如下："></a>当前示例表ttt的记录如下：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from ttt;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在会话1中执行：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">begin;update ttt set id=100 where id=1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在会话2中执行：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set @@session.tx_isolation=&apos;read-committed&apos;;</span><br><span class="line">begin;</span><br><span class="line">select * from ttt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  会话2中查询得到的结果为id=1，因为查询的是最新提交的快照数据，而最新提交的快照数据就是id=1。 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<h6 id="现在将会话1中的事务提交。"><a href="#现在将会话1中的事务提交。" class="headerlink" title="现在将会话1中的事务提交。"></a>现在将会话1中的事务提交。</h6><blockquote>
<p>在会话1中执行：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在会话2中查询记录：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from ttt;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|  100 |</span><br><span class="line">|    2 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果为id=100，因为这个值是最新提交的。  </p>
<p>再次在会话1中修改该值并提交事务。  </p>
</blockquote>
<blockquote>
<p>在会话1中执行：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">begin;update ttt set id=1000 where id=100;commit;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在会话2中执行：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from ttt;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 1000 |</span><br><span class="line">|    2 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>发现结果变成了1000，因为1000是最新提交的数据。  </p>
</blockquote>
<blockquote>
<p>read committed隔离级别的行版本读取特性，在和repeatable read隔离级别比较后就很容易理解。  </p>
</blockquote>
<h5 id="repeatable-read"><a href="#repeatable-read" class="headerlink" title="repeatable read"></a>repeatable read</h5><blockquote>
<p>同样是和上面一样的废话，对于熟悉SQL Server的人来说，在说明这个隔离级别之前，必须先给个提醒：MariaDB/MySQL中的重复读和SQL Server中的重复读完全不一样，MariaDB/MySQL中该级别基本类似于SQL Server中快照隔离级别。  </p>
</blockquote>
<blockquote>
<p>在SQL Server中，重复读的查询会申请共享锁，并且在查询结束的一刻不释放共享锁，而是持有到事务结束。所以会造成比较严重的读写并发问题。SQL Server中快照隔离级别实现的是事务级的事务一致性，每次事务开启的时候获取最新的已提交行版本，只要事务不结束，读取的记录将一直是该行版本中的数据，不管其他事务是否已经提交过对应的数据了。但是SQL Server中的快照隔离会有更新冲突：当检测到两边都想要更新同一记录时，会检测出更新冲突，这样会提前结束事务(进行的是回滚操作)而不用再显式地commit或者rollback。  </p>
</blockquote>
<blockquote>
<p>也就是说，MariaDB/MySQL中repeatable read级别总是会在事务开启的时候读取最新提交的行版本，并将该行版本一直持有到事务结束。但是MySQL中的repeatable read级别下不会像SQL Server一样出现更新冲突的问题。  </p>
</blockquote>
<blockquote>
<p>前文说过read committed隔离级别下，读取数据时总是会去获取最新已提交的行版本。这是这两个隔离级别在”一致性非锁定读”上的区别。  </p>
</blockquote>
<blockquote>
<p>另外，MariaDB/MySQL中的repeatable read的加锁方式是next-key lock算法，它会进行范围锁定。这就避免了幻影读的问题(官方手册上说无法避免)。在标准SQL中定义的隔离级别中，需要达到serializable级别才能避免幻影读问题，也就是说MariaDB/MySQL中的repeatable read隔离级别已经达到了其他数据库产品(如SQL Server)的serializable级别，而且SQL Server中的serializable加范围锁时，在有索引的时候式锁范围比较不可控(你不知道范围锁锁住哪些具体的范围)，而在MySQL中是可以判断锁定范围的(见innodb锁算法)。  </p>
</blockquote>
<blockquote>
<p>这里要演示的就是在该级别下，读取的行版本数据是不随提交而改变的。  </p>
</blockquote>
<h6 id="当前示例表ttt的记录如下：-2"><a href="#当前示例表ttt的记录如下：-2" class="headerlink" title="当前示例表ttt的记录如下："></a>当前示例表ttt的记录如下：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from ttt;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 | </span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在会话1执行：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">begin;update ttt set id=100 where id=1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在会话2中执行：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set @@session.tx_isolation=&apos;repeatable-read&apos;;</span><br><span class="line">begin;select * from ttt;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查询的结果和预期的一样，来自开启事务前最新提交的行版本数据  </p>
</blockquote>
<blockquote>
<p>回到会话1提交事务：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再回到会话2中查询：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from ttt;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再次去会话1更新该记录：   </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">begin;update ttt set id=1000 where id=100;commit;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再回到会话2执行查询：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from ttt;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>发现结果根本就不会改变，因为会话2开启事务时获取的行版本的id=1，所以之后读取的一直都是id=1所在的行版本。  </p>
</blockquote>
<h5 id="serializable"><a href="#serializable" class="headerlink" title="serializable"></a>serializable</h5><blockquote>
<p>在SQL Server中，serializable隔离级别会将查询申请的共享锁持有到事务结束，且申请的锁是范围锁，范围锁的情况根据表有无索引而不同：无索引时锁定整个表，有索引时锁定某些范围，至于锁定哪些具体的范围我发现是不可控的(至少我无法推测和计算)。这样就避免了幻影读的问题。  </p>
</blockquote>
<blockquote>
<p>这种问题在MariaDB/MySQL中的repeatable read级别就已经实现了，MariaDB/MySQL中的next-key锁算法在加范围锁时也分有无索引：无索引时加锁整个表(实际上不是表而是无穷大区间的行记录)，有索引时加锁部分可控的范围。  </p>
</blockquote>
<blockquote>
<p>MariaDB/MySQL中的serializable其实类似于repeatable read，只不过所有的select语句会自动在后面加上lock in share mode。也就是说会对所有的读进行加锁，而不是读取行版本的快照数据，也就不再支持”一致性非锁定读”。这样就实现了串行化的事务隔离：每一个事务必须等待前一个事务(哪怕是只有查询的事务)结束后才能进行哪怕只是查询的操作。  </p>
</blockquote>
<h6 id="这个隔离级别对并发性来说，显然是有点太严格了。"><a href="#这个隔离级别对并发性来说，显然是有点太严格了。" class="headerlink" title="这个隔离级别对并发性来说，显然是有点太严格了。"></a>这个隔离级别对并发性来说，显然是有点太严格了。</h6></div><div class="tags"><a href="/tags/Linux/">Linux</a><a href="/tags/MYSQL/">MYSQL</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2017/05/22/MYSQL 数据库的日志介绍/" class="pre">MYSQL 数据库的日志介绍</a><a href="/2017/05/08/MASQL MariaDB 用户权限管理/" class="next">MASQL MariaDB 用户权限管理</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Inhalte</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#事务特性"><span class="toc-text">事务特性</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#事务具有ACID特性：原子性-A-atomicity-、一致性-C-consistency-、隔离性-I-isolation-、持久性-D-durabulity-。"><span class="toc-text">事务具有ACID特性：原子性(A,atomicity)、一致性(C,consistency)、隔离性(I,isolation)、持久性(D,durabulity)。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#原子性：事务内的所有操作要么都执行，要么都不执行。"><span class="toc-text">原子性：事务内的所有操作要么都执行，要么都不执行。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#一致性：事务开始和结束前后，数据都满足数据一致性约束，而不是经过事务控制之后数据变得不满足条件或业务规则。"><span class="toc-text">一致性：事务开始和结束前后，数据都满足数据一致性约束，而不是经过事务控制之后数据变得不满足条件或业务规则。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#隔离性：事务之间不能互影响，它们必须完全的各行其道，互不可见。"><span class="toc-text">隔离性：事务之间不能互影响，它们必须完全的各行其道，互不可见。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#持久性：事务完成后，该事务内涉及的数据必须持久性的写入磁盘保证其持久性。当然，这是从事务的角度来考虑的的持久性，从操作系统故障或硬件故障来说，这是不一定的。"><span class="toc-text">持久性：事务完成后，该事务内涉及的数据必须持久性的写入磁盘保证其持久性。当然，这是从事务的角度来考虑的的持久性，从操作系统故障或硬件故障来说，这是不一定的。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务分类"><span class="toc-text">事务分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#扁平事务"><span class="toc-text">扁平事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#带有保存点的扁平事务"><span class="toc-text">带有保存点的扁平事务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#通过在事务内部的某个位置使用savepoint，将来可以在事务中回滚到此位置。"><span class="toc-text">通过在事务内部的某个位置使用savepoint，将来可以在事务中回滚到此位置。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#链式事务"><span class="toc-text">链式事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#嵌套事务"><span class="toc-text">嵌套事务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#关于嵌套事务的机制，主要有以下3个结论："><span class="toc-text">关于嵌套事务的机制，主要有以下3个结论：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#不管怎么样，最好少用嵌套事务。且MariaDB-MySQL不原生态支持嵌套事务-SQL-Server支持-。"><span class="toc-text">不管怎么样，最好少用嵌套事务。且MariaDB/MySQL不原生态支持嵌套事务(SQL Server支持)。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分布式事务"><span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#将多个服务器上的事务-节点-组合形成一个遵循事务特性-acid-的分布式事务。"><span class="toc-text">将多个服务器上的事务(节点)组合形成一个遵循事务特性(acid)的分布式事务。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事务控制语句"><span class="toc-text">事务控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#将completion-type设置为2，进行测试。"><span class="toc-text">将completion_type设置为2，进行测试。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#提交后，再查询或者进行其他操作，结果提示已经和MariaDB-MySQL服务器断开连接了。"><span class="toc-text">提交后，再查询或者进行其他操作，结果提示已经和MariaDB/MySQL服务器断开连接了。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#显式事务的次数统计"><span class="toc-text">显式事务的次数统计</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#通过全局状态变量com-commit和com-rollback可以查看当前已经显式提交和显式回滚事务的次数。还可以看到回滚到保存点的次数。"><span class="toc-text">通过全局状态变量com_commit和com_rollback可以查看当前已经显式提交和显式回滚事务的次数。还可以看到回滚到保存点的次数。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一致性非锁定读-快照查询"><span class="toc-text">一致性非锁定读(快照查询)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#当前示例表ttt的记录如下："><span class="toc-text">当前示例表ttt的记录如下：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#在会话1执行："><span class="toc-text">在会话1执行：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#在会话2中执行："><span class="toc-text">在会话2中执行：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#查询的结果和预期的一样，来自开启事务前最新提交的行版本数据。"><span class="toc-text">查询的结果和预期的一样，来自开启事务前最新提交的行版本数据。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一致性锁定读"><span class="toc-text">一致性锁定读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务隔离级别"><span class="toc-text">事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#设置和查看事务隔离级别"><span class="toc-text">设置和查看事务隔离级别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#read-uncommitted"><span class="toc-text">read uncommitted</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#read-committed"><span class="toc-text">read committed</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#当前示例表ttt的记录如下：-1"><span class="toc-text">当前示例表ttt的记录如下：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#现在将会话1中的事务提交。"><span class="toc-text">现在将会话1中的事务提交。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#repeatable-read"><span class="toc-text">repeatable read</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#当前示例表ttt的记录如下：-2"><span class="toc-text">当前示例表ttt的记录如下：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#serializable"><span class="toc-text">serializable</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#这个隔离级别对并发性来说，显然是有点太严格了。"><span class="toc-text">这个隔离级别对并发性来说，显然是有点太严格了。</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/Nginx 各种实验演示/">Nginx 各种实验演示</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/Nginx 详细介绍/">Nginx 详细介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/日志管理介绍/">日志管理介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/Linux 防火墙各种规则实战应用/">Linux 防火墙各种规则实战应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/keepalived高可用/">Ansible</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/15/memcache  缓存原理介绍/">memcache  缓存原理介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/08/tomcat 各种架构实验演示/">tomcat 各种架构实验演示</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/05/浅谈 tomcat 原理/">浅谈 tomcat 原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/25/Varnish 缓存服务器介绍/">Varnish 缓存服务器介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/14/keepalived 各种高可用实战演练/">keepalived 各种高可用实战演练</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/varnish/" style="font-size: 15px;">varnish</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/DNS/" style="font-size: 15px;">DNS</a> <a href="/tags/haproxy/" style="font-size: 15px;">haproxy</a> <a href="/tags/LAMP/" style="font-size: 15px;">LAMP</a> <a href="/tags/权限管理/" style="font-size: 15px;">权限管理</a> <a href="/tags/用户组/" style="font-size: 15px;">用户组</a> <a href="/tags/练习题/" style="font-size: 15px;">练习题</a> <a href="/tags/文件系统/" style="font-size: 15px;">文件系统</a> <a href="/tags/su和sudo/" style="font-size: 15px;">su和sudo</a> <a href="/tags/MYSQL/" style="font-size: 15px;">MYSQL</a> <a href="/tags/SSH/" style="font-size: 15px;">SSH</a> <a href="/tags/TCP-IP/" style="font-size: 15px;">TCP/IP</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/DHCP/" style="font-size: 15px;">DHCP</a> <a href="/tags/keepalied/" style="font-size: 15px;">keepalied</a> <a href="/tags/自动化/" style="font-size: 15px;">自动化</a> <a href="/tags/memcache/" style="font-size: 15px;">memcache</a> <a href="/tags/lvs/" style="font-size: 15px;">lvs</a> <a href="/tags/rpm/" style="font-size: 15px;">rpm</a> <a href="/tags/tomcat/" style="font-size: 15px;">tomcat</a> <a href="/tags/共享服务/" style="font-size: 15px;">共享服务</a> <a href="/tags/自动化安装/" style="font-size: 15px;">自动化安装</a> <a href="/tags/基本命令/" style="font-size: 15px;">基本命令</a> <a href="/tags/CA/" style="font-size: 15px;">CA</a> <a href="/tags/dns/" style="font-size: 15px;">dns</a> <a href="/tags/sed/" style="font-size: 15px;">sed</a> <a href="/tags/mini系统/" style="font-size: 15px;">mini系统</a> <a href="/tags/进程管理、计划任务/" style="font-size: 15px;">进程管理、计划任务</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archiv</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">RSS</a> |  <a href="/about/">Über</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">John Doe.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>