<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="layout: posttitle: Nginx各种实验演示date: 2017-8-02tags:  Linux nginx   实验：Nginx 实现 SSL 加密要实现 SSL 加密首先在服务器上生成证书，如：创建 CA 第一种方法：    cd /etc/pki/CA(umask 077;openssl genrsa -out private/cakey.pem 2048)openssl">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2018/08/09/Nginx 各种实验演示/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="layout: posttitle: Nginx各种实验演示date: 2017-8-02tags:  Linux nginx   实验：Nginx 实现 SSL 加密要实现 SSL 加密首先在服务器上生成证书，如：创建 CA 第一种方法：    cd /etc/pki/CA(umask 077;openssl genrsa -out private/cakey.pem 2048)openssl">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-08-27T01:31:04.669Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="layout: posttitle: Nginx各种实验演示date: 2017-8-02tags:  Linux nginx   实验：Nginx 实现 SSL 加密要实现 SSL 加密首先在服务器上生成证书，如：创建 CA 第一种方法：    cd /etc/pki/CA(umask 077;openssl genrsa -out private/cakey.pem 2048)openssl">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Nginx 各种实验演示" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/09/Nginx 各种实验演示/" class="article-date">
  <time datetime="2018-08-09T07:55:09.765Z" itemprop="datePublished">2018-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>layout: post<br>title: Nginx各种实验演示<br>date: 2017-8-02<br>tags:</p>
<ul>
<li>Linux</li>
<li>nginx</li>
</ul>
<hr>
<h2 id="实验：Nginx-实现-SSL-加密"><a href="#实验：Nginx-实现-SSL-加密" class="headerlink" title="实验：Nginx 实现 SSL 加密"></a>实验：Nginx 实现 SSL 加密</h2><p>要实现 SSL 加密首先在服务器上生成证书，如：<br>创建 CA 第一种方法：<br>    cd /etc/pki/CA<br>(umask 077;openssl genrsa -out private/cakey.pem 2048)<br>openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3650<br>            然后输入一些地区单位信息等，如：<br>                            CN<br>                             beijing<br>                             beijing<br>                             magedu<br>                             opt<br>                             <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a><br> 这样 CA 的自签名证书就创建好了，还要创建两个文件  </p>
<p> touch serial index.txt<br>echo 01 &gt; serial  </p>
<p>接下来为 nginx 向 CA 申请证书<br> cd /etc/nginx/<br>mkdir ssl<br>cd ssl<br>(umask 077;openssl genrsa -out nginx.key 1024)<br>openssl req -new -key nginx.key -out nginx.csr<br>             然后输入一些地区单位信息等，如：<br>                            CN<br>                             beijing<br>                             beijing<br>                             magedu<br>                             opt<br>                             <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a><br><a id="more"></a><br>接下来 ca 颁发证书<br>openssl ca -in nginx.csr -out nginx.crt -days 3655<br>这样就生成 nginx 证书  </p>
<p>创建 CA 第二种方法：<br>cd /etc/pki/tls/certs<br>make a.crt<br>接下来会让输入口令，这个口令是给私钥加的口令，这个口令加上后， nginx 服务启动时自动起不来了，输完口令才能起来，为了方便操作，也可以在这先加上，到后面在取消。<br>然后输入一些地区单位信息等，如：<br> CN<br>beijing<br>beijing<br>magedu<br>opt<br><a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a><br>这时候就在当前目录下生成两个文件，一个私钥文件，一个自签名证书文件，如： a.key  ,  a.crt<br>如果在前面给私钥加了密，现在就可以给解下密，如：<br>openssl rsa -in a.key -out aa.key<br> 生成的这个 aa.key 跟原来一样就是不加密了<br>接下来就可以把 生成的文件复制到 nginx 的配置文件目录下<br>cp a.crt aa.key /etc/nginx/conf.d/<br>cd /etc/nginx/conf.d/<br>为了好看，可以把 aa.key 文件名在改过来。<br>mv aa.key a.key  </p>
<p>然后在当前目录下创建配置文件，vim vhosts.conf  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> listen 443 ssl;</span><br><span class="line"> server_name www.a.com;</span><br><span class="line"> root /data/sitea/;               # 这个目录表示 url 的根目录</span><br><span class="line"> ssl on; </span><br><span class="line">ssl_certificate /etc/nginx/conf.d/a.crt;</span><br><span class="line"> ssl_certificate_key /etc/nginx/conf.d/a..key; </span><br><span class="line">ssl_session_cache shared:sslcache:20m; </span><br><span class="line">ssl_session_timeout 10m; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来重启服务    nginx<br>就会发现端口 443 已经开启<br>然后就可以在远程服务器上进行测试连接了<br>在远程服务器上   curl -k https:// <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a><br>也可以在浏览器上输入 IP   进行访问，如果要在浏览器上输入网址，就还得 DNS 解析才行。<br>在浏览器上输入      https:// <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a><br>当然这个证书是没有可信度的，在具体生产中要想实现 https ，那就花钱买正规证书，然后把放在对应的目录下就可以了。<br>这就是 SSL 的实现  </p>
<h2 id="实验：在一台-Nginx-服务器上实现搭建多个加密网站"><a href="#实验：在一台-Nginx-服务器上实现搭建多个加密网站" class="headerlink" title="实验：在一台 Nginx 服务器上实现搭建多个加密网站"></a>实验：在一台 Nginx 服务器上实现搭建多个加密网站</h2><p>在 apache 上要想在一台物理服务器上实现多个 https 的虚拟主机网站是不行的，但是在 nginx 上是可以实现的，因为 nginx 上支持     SNI 技术，所谓的 SNI 技术表示服务器的名称扩展，这个技术就可以让我们在一台物理服务器上实现多个 https 的网站。  </p>
<p>  那么现在来实现以下在一台服务器上实现多个加密的网站。比如：   <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a>     <a href="http://www.b.com" target="_blank" rel="noopener">www.b.com</a><br>首先准备两个证书，过程如上，在这就不细说。<br>两个证书准备好后，然后放到相应的目录下。然后写配置文件，如：<br>cd /etc/nginx/conf.d/<br>vim vhosts.conf  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> listen 443 ssl;</span><br><span class="line"> server_name www.a.com;</span><br><span class="line"> root /data/sitea/;               # 这个目录表示 url 的根目录</span><br><span class="line"> ssl on; </span><br><span class="line">ssl_certificate /etc/nginx/conf.d/a.crt;</span><br><span class="line"> ssl_certificate_key /etc/nginx/conf.d/a..key; </span><br><span class="line">ssl_session_cache shared:sslcache:20m; </span><br><span class="line">ssl_session_timeout 10m; </span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line"> listen 443 ssl;</span><br><span class="line"> server_name www.b.com;</span><br><span class="line"> root /data/siteb/;               # 这个目录表示 url 的根目录</span><br><span class="line"> ssl on; </span><br><span class="line">ssl_certificate /etc/nginx/conf.d/b.crt;</span><br><span class="line"> ssl_certificate_key /etc/nginx/conf.d/b.key; </span><br><span class="line">ssl_session_cache shared:sslcache:20m; </span><br><span class="line">ssl_session_timeout 10m; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来重启服务    nginx<br>然后就可以测试了，当然要是直接在浏览器上输入 网址，还需要 DNS 解析。<br>当然即使解析了浏览器也会报网站不安全，因为证书是我们自签名的，浏览器比信任，要想浏览器信任，在具体生产中还得花钱购买公认的证书。<br>这就实现了 一个物理服务器上搭建多个 加密网站。  </p>
<h2 id="实验：-实现-nginx-服务，fastcgi-模式之间的搭建连接。"><a href="#实验：-实现-nginx-服务，fastcgi-模式之间的搭建连接。" class="headerlink" title="实验： 实现 nginx 服务，fastcgi 模式之间的搭建连接。"></a>实验： 实现 nginx 服务，fastcgi 模式之间的搭建连接。</h2><p>准备四台服务器来模拟实验，分别用来当做 客户端、nginx 服务器、fastcgi 服务器、mysql 数据库服务器。<br>客户端服务器的地址为 192.168.30.6<br>fastcgi 服务器的地址为 192.168.30.17</p>
<p>首先在192.168.30.7 主机上安装 nginx 服务并启动<br>yum install nginx<br>nginx<br>接下来添加配置文件让能够连接后端的 fastcgi 程序<br>vim /etc/nginx/conf.d/vhosts.conf<br>添加内容      </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">fastcgi_pass 192.168.30.17:9000; </span><br><span class="line">                 fastcgi_index index.php;</span><br><span class="line">                 fastcgi_param SCRIPT_FILENAME</span><br><span class="line">                 /data/php$fastcgi_script_name; </span><br><span class="line">                 include fastcgi_params; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加完后重新加载配置文件<br>nginx -s reload  </p>
<p>在192.168.30.17 服务器上安装 php-fpm 包<br>yum install php-fpm<br>修改配置文件      vim /etc/php-fpm.d/<a href="http://www.conf" target="_blank" rel="noopener">www.conf</a><br>修改   listen = 127.0.0.1:9000   改为   listen = 9000<br>          listen.allowed_clients = 127.0.0.1    改为<br>          listen.allowed_clients = 192.168.30.7<br>          这块的 IP 为前端 nginx 服务器的地址<br>修改完重启服务<br>systemctl start php-fpm<br>创建一个文件夹，将来存放 php 程序的文件<br>mkdir /data/php<br>cd /data/php/<br>添加一些测试文件  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br><span class="line">&lt;?</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim tset.php</span><br><span class="line">&lt;?php</span><br><span class="line">$dsn=&apos;mysql:host=192.168.30.27;dbname=mysql&apos;;</span><br><span class="line">$username=&apos;test&apos;;</span><br><span class="line">$passwd=&apos;centos&apos;;</span><br><span class="line">$dbh=new PDO($dsn,$username,$passwd);</span><br><span class="line">var_dump($dbh);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>接下来就可以拿浏览器访问 nginx 服务器了。<br>这就实现了 fastcgi 的php程序。不过一般在生产中为了节约物理服务器，这两个还是放在一起的，在这只是为了演示原理分开测试的。  </p>
<p>如果 nginx 服务器作为中间的一个调度器，后端比如有两个提供外部服务的服务器，那如何调度，首先在后端的外部服务器上设置好各自的服务跟站点页面。然后在 nginx 服务器配置文件的 http 语句块中添加：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream www &#123;</span><br><span class="line">server 192.168.30.200:80;    #    表示后端的外部服务器地址</span><br><span class="line">server 192.168.30.17:80;        #    表示后端的外部服务器地址</span><br><span class="line">&#125;</span><br><span class="line">     location / &#123;</span><br><span class="line">proxy_pass http://www;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在浏览器上进行访问就ok 了，注意访问的是 nginx 服务器的地址。<br>当然，如果后端的外部服务器有一个宕机，前面的 nginx 服务器会立即察觉，并且立即不往那台服务器上调度。不用手动配置什么，一切动作都是自动的。<br>说明 nginx 服务器还有自动健康检查功能。<br>还有如果后端的外部服务器端口发生变化，直接在 nginx 服务器配置文件中进行修改即可，并重启服务。  </p>
<h2 id="实验：-实现-nginx-源码编译"><a href="#实验：-实现-nginx-源码编译" class="headerlink" title="实验： 实现 nginx 源码编译"></a>实验： 实现 nginx 源码编译</h2><p>先在官网上下载源码包到本机          官网： <a href="http://www.nginx.org" target="_blank" rel="noopener">www.nginx.org</a><br>下载包：   nginx-1.12.2.tar.gz<br>下载完解包<br>tar xvf nginx-1.12.2.tar.gz<br>解完包生成一个文件夹<br>nginx-1.12.2<br>解完包对源码进行修改，比如，对外 发布的版本号<br>cd nginx-1.12.2<br>vim src/http/ngx_http_header_filter_module.c<br>在里面进行修改    查找 48 行<br>修改  static u_char ngx_http_server_string[] = “Server: nginx” CRLF;   为：<br>          static u_char ngx_http_server_string[] = “Server: Linginx” CRLF;  （可以自己随意修改字段）  </p>
<p>还有一个就是修改 nginx 版本号<br>vim src/core/nginx.h<br>在里面有版本号，然后进行修改。  </p>
<p>安装包组<br>yum groupinstall “development tools”<br>接下来创建一个 nginx 账号，因为一会 work 进程要以 nginx 的身份运行<br>useradd -r nginx<br>然后 cd 到 nginx-1.12.2 目录下进行编译<br>./configure –prefix=/app/nginx \<br> –conf-path=/etc/nginx/nginx.conf \<br>– error-log-path=/var/log/nginx/error.log \<br>–http-logpath=/var/log/nginx/access.log \<br>–pid-path=/var/run/nginx.pid \<br>–lockpath=/var/run/nginx.lock \<br>–user=nginx \<br>–group=nginx \<br>–with-http_ssl_module \<br>–with-http_v2_module \<br>–with-http_dav_module \<br>–withhttp_stub_status_module \<br>–with-threads \<br>–with-file-aio  </p>
<p>中间可能会提示缺包，提示缺什么包装上就可以了<br>如： yum install pcre-devel<br>        yum install openssl-devel  </p>
<p>make -j 4 &amp;&amp; make install  </p>
<p>编译完后在 /app/nginx/sbin/ 目录下有一个 nginx 程序<br>运行这个程序启动服务<br>./nginx<br>可以直接把这个工具加入 PASH 变量中<br>如果想干脆把让客户看到版本号，那就修改主配置文件<br>vim /etc/nginx/conf/nginx.conf<br>在 http 语句块中添加<br>server_tokens off;<br>修改完重新加载配置文件    ./nginx -s reload<br>这样客户端就看不见服务版本了  </p>
<p>到此就编译成功了。  </p>
<h2 id="实验：-实现-nginx-的反向代理功能"><a href="#实验：-实现-nginx-的反向代理功能" class="headerlink" title="实验：  实现 nginx 的反向代理功能"></a>实验：  实现 nginx 的反向代理功能</h2><p>现在准备三台主机来模拟实验环境，一个客户端，一个 nginx 服务器， 一个后端提供服务的 httpd 服务器。     实验模拟：   172 网段属于外网，  192 网段的属于内网<br>现在配置环境，客户机上的网卡网段是 172，IP 为 172.20.101.101<br> nginx 服务器上有两个网卡，一个是 172 网段的，IP 为  172.20.116.116   ， 一个是 192 网段的，IP 为 192.168.30.7 。<br>后端服务器上网卡的网段是 192 网段的，IP 为 192.168.30.17  </p>
<p>先在后端提供外部服务的 httpd 服务器上安装 httpd 服务并启动<br>yum install httpd<br>systemctl start httpd  </p>
<p>然后在 nginx 服务器上安装 nginx 服务，并配置反向代理功能<br>在配置文件中添加：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://192.168.30.17/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用 客户机去访问 nginx 服务器的80 端口 ，curl 172.20.116.116<br>就会收到后端提供服务的外部服务器主页面的内容。<br>然后在后端的提供服务的外部服务器上的日志中收到发来的请求，就会发现日志显示的请求 ip 是 nginx 服务器的。<br>但在 nginx 服务器上的日志中会显示真正客户端发来的请求。<br>以上就实现了简单的 nginx 服务的反向代理  </p>
<p>如果后端的外部服务器上端口进行修改，修改为 8080，那么就要在 nginx 服务器配置文件中进行修改，如：<br>       l<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ocation / &#123;</span><br><span class="line">proxy_pass http://192.168.30.17：8080/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果只允许访问特定目录时才给转到后端外部服务器上去，怎么配置？   如：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /bbs &#123;</span><br><span class="line">proxy_pass http://192.168.30.17/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>        这里面 IP 后面加斜线，我们表示有 URL ，当访问 /bbs 目录时就会把这个目录置换为 IP 下的根，而不加斜线，就会把 /bbs 目录添加在地址后面充当我的 URL 。<br>        这里面 IP 后面加斜线，反向代理后访问到的是后端服务器默认的主站点页面文件，而不加斜线则访问到的是根下的 /bbs 目录下的文件</p>
<h2 id="实验：-实现-nginx-服务反向代理，并要求客户端访问静态页面就调度到外部1服务器上，访问动态页面就调度到外部2-服务器上，并且动态服务器后还有对应的数据库服务器，-实现动静分离。"><a href="#实验：-实现-nginx-服务反向代理，并要求客户端访问静态页面就调度到外部1服务器上，访问动态页面就调度到外部2-服务器上，并且动态服务器后还有对应的数据库服务器，-实现动静分离。" class="headerlink" title="实验： 实现 nginx 服务反向代理，并要求客户端访问静态页面就调度到外部1服务器上，访问动态页面就调度到外部2 服务器上，并且动态服务器后还有对应的数据库服务器，  实现动静分离。"></a>实验： 实现 nginx 服务反向代理，并要求客户端访问静态页面就调度到外部1服务器上，访问动态页面就调度到外部2 服务器上，并且动态服务器后还有对应的数据库服务器，  实现动静分离。</h2><p>准备实验环境<br>准备 5 台服务器，分别为  192.168.30.6      192.168.30.7    192.168.30.200    192.168.30.17     192.168.30.27<br>用 192.168.30.6  主机当客户端服务器<br>用 192.168.30.7 主机当 nginx 服务器，还有一个地址   172.20.116.116<br>用 192.168.30.200 主机当外部1 服务器<br>用 192.168.30.17 主机当外部2 服务器<br>用 192.168.30.27 主机当外部2 服务器后的数据库服务器  </p>
<p>先配置外部服务器<br>在外部1 服务器 192.168.30.200 上安装 httpd 服务并启动<br>yum install httpd<br>设置静态页面<br>cd /var/www/html<br>echo static page &gt; index.html<br>systemctl start httpd  </p>
<p>在外部 2服务器 192.168.30.17 上安装 httpd php-fpm php-mysql<br>yum install httpd php-fpm php-mysql<br>systemctl start httpd php-fpm  </p>
<p>在数据库服务器 192.168.30.27 安装 mysql 数据库<br>yum install mariadb-server<br>创建数据库账号<br>grant all on <em>.</em> to test@’192.168.30.%’ identfied by ‘centos’;<br>加载数据库<br>flush privileges;  </p>
<p>然后回到外部2 服务器  192.168.30.17 上修改配置文件   vim /etc/httpd/conf.d/php.conf<br>在里面添加        </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DirectoryIndex index.php </span><br><span class="line">ProxyRequests Off </span><br><span class="line">ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/var/www/html/$1</span><br></pre></td></tr></table></figure>
<p>写连接数据库的php 程序配置文件<br>cd /var/www/html/<br>vim tset.php<br>在里面添加  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$dsn=&apos;mysql:host=192.168.30.27;dbname=mysql&apos;;</span><br><span class="line">$username=&apos;test&apos;;</span><br><span class="line">$passwd=&apos;centos&apos;;</span><br><span class="line">$dbh=new PDO($dsn,$username,$passwd);</span><br><span class="line">var_dump($dbh);</span><br><span class="line">?&gt;</span><br><span class="line">然后再在这个目录下创建一个 php程序文件   </span><br><span class="line">vim php.html</span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>重启服务<br>systemctl restart httpd  </p>
<p>然后回到 nginx 服务器 192.168.30.7 上配置反向代理<br>在配置文件中添加       vim /etc/nginx/conf.d/vhosts.conf  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">proxy_pass http://192.168.30.17;</span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://192.168.30.200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后拿客户端访问 nginx 服务器，在浏览器输入   172.20.116.116/test.php  ， 如果出现” object(PDO)#1 (0) { } “    这个字符串，就表示调度到 外部 2 服务器上，输入   172.20.116.116/index.html   ,如果出现  “static page”   这个字符串就表示调度到 外部 1服务器上。<br>这就实现了动静分离，访问静态页面调度到一台服务器，访问动态页面调度到另一台服务器。这样就有效的把服务器的负载分配到不同服务器上，提高了服务器性能。  </p>
<p>   在上面唯一遗憾的就是在后端提供外部服务的服务器日志中显示访问的主机 IP 为 nginx 反向代理服务器的。这样对以后分析哪些地方 的客户访问了哪些页面就不太方便了，为了能够在后端服务器上显示原访问客户端的 IP 地址，就要在 nginx 服务器转发请求报文时在报文头部添加一些指令，把客户端的地址添加到报文头部中，这样在后端的服务器日志中就可以看到客户端的地址了。  </p>
<p>   但是在后端服务器的日志中他只记录访问用户的地址，并不记录报文头部的地址，所以还要在后端的服务器上修改日志格式才行。<br>    在 nginx 服务器上添加报文头部信息<br>proxy_set_header remoteclientip $remote_addr;<br>   这个信息可以放在 location、server 、http 这三个语句块中都可以。<br>          还要在后端的外部服务器上修改日志格式  ，在服务的配置文件中进行修改。<br>            vim /etc/httpd/conf/httpd.conf<br>  修改下面这条指令：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogFormat &quot;%&#123;remoteclientip&#125;i %l %u %&#123;%F %T&#125;t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot;&quot; combined</span><br></pre></td></tr></table></figure>
<p>   修改完重启服务<br>systemctl restart httpd  </p>
<p>   如果在生产中，客户端访问后端服务器，中间要经过好几台 nginx 反向服务器，最后面才是 提供外部服 务的外部服务器，那么这样怎么在后端服务器上记录真实客户端的访问地址？<br>   一般只用在最前面的 nginx 服务器配置文件中添加以下两条 ：<br>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>        中间的 nginx 服务器配置文件中只用添加相应的反向代理地址即可。  </p>
<p> 注意：如果外部服务器前面有好多反向代理服务器，前面的服务器配置文件中的转发 IP 一定是后面那个转发服务器的地址，不是后面外部服务器的地址，这样一次类推，直到外部服务器前的那一个转发服务器的配置文件中才是 后端外部服务器的地址。  </p>
<p>这样只在后端的外部服务日志中记录真实客户端的地址，不记录中间经过的 nginx 服务器的地址。<br>如果在生产中有需求，需要经过的地址都记录，就在所有经过的 nginx 服务器配置文件中添加 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  这条就可以。  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/09/Nginx 各种实验演示/" data-id="cjlbm6jrw000ncgrb7h54nvbv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/08/09/Nginx 详细介绍/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CA/">CA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DHCP/">DHCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS/">DNS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LAMP/">LAMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MYSQL/">MYSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dns/">dns</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/haproxy/">haproxy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keepalied/">keepalied</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lvs/">lvs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcache/">memcache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mini系统/">mini系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rpm/">rpm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sed/">sed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/su和sudo/">su和sudo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/varnish/">varnish</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/共享服务/">共享服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基本命令/">基本命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文件系统/">文件系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/权限管理/">权限管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/用户组/">用户组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/练习题/">练习题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化/">自动化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化安装/">自动化安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/进程管理、计划任务/">进程管理、计划任务</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CA/" style="font-size: 10px;">CA</a> <a href="/tags/DHCP/" style="font-size: 10px;">DHCP</a> <a href="/tags/DNS/" style="font-size: 15px;">DNS</a> <a href="/tags/LAMP/" style="font-size: 10px;">LAMP</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/MYSQL/" style="font-size: 15px;">MYSQL</a> <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/dns/" style="font-size: 10px;">dns</a> <a href="/tags/haproxy/" style="font-size: 10px;">haproxy</a> <a href="/tags/keepalied/" style="font-size: 10px;">keepalied</a> <a href="/tags/lvs/" style="font-size: 10px;">lvs</a> <a href="/tags/memcache/" style="font-size: 10px;">memcache</a> <a href="/tags/mini系统/" style="font-size: 10px;">mini系统</a> <a href="/tags/mysql/" style="font-size: 17.5px;">mysql</a> <a href="/tags/rpm/" style="font-size: 10px;">rpm</a> <a href="/tags/sed/" style="font-size: 10px;">sed</a> <a href="/tags/su和sudo/" style="font-size: 10px;">su和sudo</a> <a href="/tags/tomcat/" style="font-size: 12.5px;">tomcat</a> <a href="/tags/varnish/" style="font-size: 10px;">varnish</a> <a href="/tags/共享服务/" style="font-size: 12.5px;">共享服务</a> <a href="/tags/基本命令/" style="font-size: 10px;">基本命令</a> <a href="/tags/文件系统/" style="font-size: 12.5px;">文件系统</a> <a href="/tags/权限管理/" style="font-size: 10px;">权限管理</a> <a href="/tags/用户组/" style="font-size: 10px;">用户组</a> <a href="/tags/练习题/" style="font-size: 10px;">练习题</a> <a href="/tags/自动化/" style="font-size: 10px;">自动化</a> <a href="/tags/自动化安装/" style="font-size: 10px;">自动化安装</a> <a href="/tags/进程管理、计划任务/" style="font-size: 10px;">进程管理、计划任务</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/09/Nginx 各种实验演示/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/08/09/Nginx 详细介绍/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/08/09/日志管理介绍/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/08/09/Linux 防火墙各种规则实战应用/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/08/08/keepalived高可用/">Ansible</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>